import { execSync } from 'child_process'
import fs from 'fs-extra'
import path from 'path'
import { log } from './utils.mjs'
import { fixOfflinePaths } from './fix-offline-paths.mjs'
import { glob } from 'glob'

/**
 * Build the project with offline compatibility for ThemeForest submission
 * This creates a file:// compatible version of the site
 */
async function buildOffline() {
  try {
    log('Starting offline build...', 'info', 'BUILD-OFF')

    // Clean the offline build directory
    const offlineDir = './dist/offline'
    if (fs.existsSync(offlineDir)) {
      fs.removeSync(offlineDir)
      log('Cleaned previous offline build', 'info', 'BUILD-OFF')
    }

    // Ensure offline directory exists
    fs.ensureDirSync(offlineDir)

    // Build Astro with offline config
    log('Building Astro pages for offline use...', 'info', 'BUILD-OFF')
    execSync('astro build --config config/astro.offline.config.mjs', {
      stdio: 'inherit',
      env: { ...process.env, PUBLIC_RELATIVE_PATHS: 'true' }
    })

    // Copy assets to offline build
    await copyAssetsForRelative()

    // Copy CSS and JS files
    await copyCSSJSForRelative()

    // Post-process HTML files for better offline compatibility
    await postProcessHTMLFiles()

    // Fix paths for offline use
    log('Fixing paths for offline use...', 'info', 'BUILD-OFF')
    await fixOfflinePaths()

    // Format HTML files with Prettier
    log('Formatting HTML files with Prettier...', 'info', 'BUILD-OFF')
    await formatHTMLFiles()

    log('Offline build completed successfully!', 'success', 'BUILD-OFF')
    log('Output directory: ./dist/offline', 'info', 'BUILD-OFF')
    log('You can now open any HTML file directly in a browser using file://', 'info', 'BUILD-OFF')
  } catch (error) {
    log(`Offline build failed: ${error.message}`, 'error', 'BUILD-OFF')
    throw error
  }
}

/**
 * Format HTML files using Prettier for better presentation
 * @returns {Promise<void>}
 */
async function formatHTMLFiles() {
  try {
    const files = await glob('./dist/offline/**/*.html')

    if (files.length === 0) {
      log('No HTML files found to format', 'warning', 'BUILD-OFF')
      return
    }

    log(`Found ${files.length} HTML files to format`, 'info', 'BUILD-OFF')

    // Dynamically import prettier
    const prettier = await import('prettier')

    const prettierConfig = {
      parser: 'html',
      printWidth: 120,
      tabWidth: 2,
      useTabs: false,
      singleQuote: false,
      bracketSameLine: false
    }

    // Use Promise.all for concurrent file operations to enhance performance
    const formatPromises = files.map(async (file) => {
      try {
        const content = await fs.readFile(file, 'utf8')
        const formatted = await prettier.format(content, prettierConfig)
        await fs.writeFile(file, formatted)
      } catch (error) {
        log(
          `Error formatting ${path.relative('./dist/offline', file)}: ${error.message}`,
          'error',
          'BUILD-OFF'
        )
        // Continue with other files
      }
    })

    await Promise.all(formatPromises)
    log(`Formatted ${files.length} HTML files`, 'success', 'BUILD-REL')
  } catch (error) {
    log(`HTML formatting error: ${error.message}`, 'error', 'BUILD-REL')
    // Don't throw as formatting is not critical for functionality
  }
}

/**
 * Copy assets to the offline build directory
 */
async function copyAssetsForRelative() {
  try {
    const srcAssetsDir = './src/assets'
    const destAssetsDir = './dist/offline/assets'

    if (fs.existsSync(srcAssetsDir)) {
      fs.copySync(srcAssetsDir, destAssetsDir)
      log('Assets copied to offline build', 'info', 'BUILD-OFF')
    }

    // Copy favicon files to root of relative build
    const faviconSrcDir = './src/assets/favicon'
    const offlineRootDir = './dist/offline'

    if (fs.existsSync(faviconSrcDir)) {
      const faviconFiles = fs.readdirSync(faviconSrcDir)
      faviconFiles.forEach((file) => {
        const srcPath = path.join(faviconSrcDir, file)
        const destPath = path.join(offlineRootDir, file)
        fs.copySync(srcPath, destPath)
      })
      log(`Copied ${faviconFiles.length} favicon files to offline build root`, 'info', 'BUILD-OFF')
    }

    // Note: The main index.html is generated by Astro from src/html/pages/index.astro
    // No need to copy the root redirect file as Astro builds the proper landing page
  } catch (error) {
    log(`Asset copy failed: ${error.message}`, 'error', 'BUILD-REL')
    throw error
  }
}

/**
 * Copy CSS and JS files to offline build
 */
async function copyCSSJSForRelative() {
  try {
    // Copy CSS files
    if (fs.existsSync('./dist/css')) {
      fs.copySync('./dist/css', './dist/offline/css')
      log('CSS files copied to offline build', 'info', 'BUILD-OFF')
    }

    // Copy JS files
    if (fs.existsSync('./dist/js')) {
      fs.copySync('./dist/js', './dist/offline/js')
      log('JS files copied to offline build', 'info', 'BUILD-OFF')
    }
  } catch (error) {
    log(`CSS/JS copy failed: ${error.message}`, 'error', 'BUILD-REL')
    throw error
  }
}

/**
 * Post-process HTML files to ensure proper offline compatibility
 */
async function postProcessHTMLFiles() {
  try {
    const offlineDir = './dist/offline'
    const htmlFiles = []

    // Recursively find all HTML files
    function findHTMLFiles(dir) {
      const files = fs.readdirSync(dir)
      files.forEach((file) => {
        const filePath = path.join(dir, file)
        const stat = fs.statSync(filePath)
        if (stat.isDirectory()) {
          findHTMLFiles(filePath)
        } else if (file.endsWith('.html')) {
          htmlFiles.push(filePath)
        }
      })
    }

    findHTMLFiles(offlineDir)

    // Process each HTML file
    htmlFiles.forEach((filePath) => {
      let content = fs.readFileSync(filePath, 'utf8')

      // Fix any remaining absolute paths that might have slipped through
      content = content.replace(/href="\/(?!\/)/g, 'href="./')
      content = content.replace(/src="\/(?!\/)/g, 'src="./')

      // Ensure proper relative paths for deeper nested files
      const depth = filePath.split(path.sep).length - offlineDir.split(path.sep).length - 1
      if (depth > 0) {
        const prefix = '../'.repeat(depth)
        content = content.replace(/href="\.\//g, `href="${prefix}`)
        content = content.replace(/src="\.\//g, `src="${prefix}`)
      }

      fs.writeFileSync(filePath, content)
    })

    log(`Post-processed ${htmlFiles.length} HTML files for relative paths`, 'info', 'BUILD-REL')
  } catch (error) {
    log(`HTML post-processing failed: ${error.message}`, 'error', 'BUILD-REL')
    throw error
  }
}

buildOffline()
